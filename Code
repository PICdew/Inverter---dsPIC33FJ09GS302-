/*
 * File:   Main.c
 * Author: jewalker
 *
 * Created on October 12, 2016, 3:18 PM
 */


#include "xc.h"
#include "p33fxxxx.h"

#include <math.h>
//#include "pps.h"



#define FOSC    (80000000ULL)
#define FCY     (FOSC/2)
#define high 1
#define low 0
#define Baud_Rate 259 // (Fcy/(16 * Buad Rate)) - 1 , Baud rate = 9600

 /*******************************
 * Set device configuration values
********************************/
_FOSCSEL(FNOSC_FRC    & IESO_ON);
_FOSC(FCKSM_CSECME & OSCIOFNC_OFF & POSCMD_NONE & IOL1WAY_ON);
_FWDT(FWDTEN_OFF);
_FICD(JTAGEN_OFF); 
//_FPOR(FPWRT_PWR128);
/*Global Variables*/

int j;
int i;
int duty;
int time;
int Sample1;
int sinetable2[] = {
    
48	,
95	,
143	,
190	,
237	,
284	,
331	,
378	,
424	,
471	,
516	,
562	,
607	,
652	,
697	,
741	,
784	,
827	,
870	,
912	,
953	,
994	,
1034	,
1073	,
1112	,
1150	,
1188	,
1224	,
1260	,
1295	,
1330	,
1363	,
1396	,
1427	,
1458	,
1488	,
1517	,
1545	,
1572	,
1598	,
1623	,
1647	,
1670	,
1692	,
1712	,
1732	,
1751	,
1768	,
1785	,
1800	,
1814	,
1827	,
1839	,
1850	,
1859	,
1868	,
1875	,
1881	,
1886	,
1889	,
1892	,
1893	,
1893	,
1892	,
1889	,
1886	,
1881	,
1875	,
1868	,
1860	,
1850	,
1840	,
1828	,
1815	,
1801	,
1786	,
1769	,
1752	,
1733	,
1714	,
1693	,
1671	,
1648	,
1624	,
1599	,
1573	,
1547	,
1519	,
1490	,
1460	,
1429	,
1398	,
1365	,
1332	,
1298	,
1262	,
1227	,
1190	,
1153	,
1115	,
1076	,
1036	,
996	,
956	,
914	,
872	,
830	,
787	,
743	,
699	,
655	,
610	,
565	,
519	,
473	,
427	,
381	,
334	,
287	,
240	,
193	,
146	,
98	,
51	,
3	,


};


  
// Prototypes
void InitADC(void);
void InitUART(void);
void RemapPins(void);
void SendData(void);
void InitTimer2(void);

void InitPWM();
void InitTimer1();
void InitOutPutPins();
void Delay(int);
void PWMup();
void PWMdown();
void PwmDutyUpdate();






int main(void) 
{
 /* **************Configure PLL for FOSC=80MHz using 7.37MHz FRC*****************/
         PLLFBD = 41; // M = 43
         CLKDIVbits.PLLPRE  = 0;  // N1 = 2
         CLKDIVbits.PLLPOST = 0;  // N2 = 2   
 /*******************************************************************************/    
  
/***************Initiate Clock Switch to Internal FRC with PLL (NOSC = 0b001)************/
         
     __builtin_write_OSCCONH( 0x01 );
     __builtin_write_OSCCONL( 0x01 );
  
      // Wait for Clock switch to occur
     while ( OSCCONbits.COSC != 0b001 );
 
     // Wait for PLL to lock
     while ( OSCCONbits.LOCK != 1 );
     
/*****************************************************************************************/
   
       RemapPins();
       InitOutPutPins();
       InitUART();
       InitADC();
       InitTimer2();
       
       InitPWM(); 
       InitTimer1();
       
     

     while(1)
     {
             //Do Something
     } 
       return(0);
 }





void PwmDutyUpdate(void)
{
    if(j<124)
    {
        PWMup();
    }
    else if(j>=124)
    {
        PWMdown();
    }

    if(j>=249)
    {
        j=0;
        i=0;
    }
   
    j++;
   
}


void PWMup(void)

{
        duty = sinetable2[i];
        LATBbits.LATB9 = low;
        LATBbits.LATB10 = high;
        PDC1 = duty;
        PDC2 = 0;
        i++;
 
 
}


void PWMdown(void)
{        
        duty = sinetable2[i];
        LATBbits.LATB9 = high;
        LATBbits.LATB10 = low;     
        PDC1 = 0;
        PDC2 = duty;
        i--;     
}
void InitOutPutPins(void)
{
         
       TRISA = 0b0000000000000011;// RAO/RA1 are mapped as inputs. These are ADC Pair 0
       TRISB = 0b0000000000000000; // Make RB0 an output for UART Tx
       //ADPCFGbits.PCFG3 = 1; // RB0_AN3_Rp0 - Digital?

       
       //ADPCFG = 0xfff;
       

}

/* ********************************************************************************************************
 **********This needs to be changed to Timer2. We are using Timer1 to update the PWM Duty Cycle************
 **********************************************************************************************************
 */

void InitTimer2(void)
{
    T2CONbits.TSIDL = 0; //continue timer even when device is in idle mode.
    T2CONbits.TGATE = 0;// --> when TCS = 0 this bit is ignored
    T2CONbits.TCKPS1 = 2; // 0=1:1, 1=1:8, 2=1:64, 3=1:256
    //T1CONbits.TSYNC = 0 --> Ignored when TCS=0
    T2CONbits.TCS = 0; //Internal clock. (FOSC/2)
    PR2 = (2625*2);//was 5208/2
    
    //IPC0bits.IC1IP = 1; //set interrupt priority
    //IFS0bits.T1IF = 0; //clear the timer1 interrupt flag
    //IEC0bits.T1IE = 1; //Enable timer1 interrupt
    
    T2CONbits.TON = 1; //Timer ON
}




/*The below pwm function initailizes the pwm generator to do the following: Generates an interrupt 
 * every x pwm cycles. Where x is determined by the TRGCON1bits.TRGDIV register. 
 * The idea here was to generate an interrupt at a frequency of 60Hz. I would use 
 * this interrupt to turn off the lower fets of the H-bridge. However, the slowest
 * frequency I can get to is 784Hz. I think I can get lower if I changed the main pwm clock 
 * and added pre and/or post scalers in the pwm generator. Then I would have to change the PTPER 
 * accordingly. */

void InitPWM(void)
 {
     PTCONbits.PTEN = 0; // 1 = PWM timer base ON. 0 = PWM timer base OFF
     //SEVTCMP = 1150;
     PTCONbits.PTSIDL = 0; //PWM rums in idle mode.
    
     //PTCONbits.SESTAT = 0; // Special event status bit not pending. Hardware Clear/Set
     PTCONbits.EIPU = 0; //Update PWM on cycle boundaries
     PTCONbits.SYNCPOL = 0; // Sync input/output bit. active high
     PTCONbits.SYNCOEN = 0; //sync output disabled
     PTCONbits.SYNCEN = 0;// sync of primary time base disabled
    // PTCONbits.SYNCSRC --> sync source election. Not using
     
     PTCONbits.SEVTPS0 = 0; //--> special event postscaler. Not using
     //PTCONbits.SEIEN = 1; // 0=Special event  disabled : 1=enabled    
     
     
     
     //PTCON2bits.PCLKDIV =6;// PWM input clock prescaler. 0 = divide by 64
     PTCON2bits.PCLKDIV = 0;
     
     
    //PTPER = 1893; // Empirically found to give 60Hz PWM with a PCLKDIV of 64
     PHASE1 = 2500; //1893;//65093;// was 2332 --- 2100 as of 6/2/17
     //SPHASE1  = 2500;
     //PHASE1 = 61137;
     
     PHASE2 = 2500; //gives roughly 15KHz with PCLKDIV at 3?
    //SPHASE2 = 2500;
     
     PWMCON1bits.ITB = 1; //  =0 ->Use PTPER register for pwm timing.1 -> use
     //phase and sphase
     PWMCON1bits.MDCS = 0; //use PDCx registers for duty cycle
     PWMCON1bits.DTC = 0; // 2=deadtime control disabled, 0=positive deadtime
     PWMCON1bits.CAM = 1;//center alligned mode disabled
     PWMCON1bits.XPRES = 0;// exteranl pins have no effect on pwm time base
    // DTR1 = 50;
    // ALTDTR1 = 200;
     PWMCON1bits.IUE = 0; // update PDCx with PWM time base
     //DTR1 = 500;
     
     IOCON1bits.PENH = 1; //PWMmodule controls this pin
     IOCON1bits.PENL = 1; //PWM module controls this pin
     IOCON1bits.POLH = 0; //active high pin
     IOCON1bits.POLL = 0; //active high pin
     IOCON1bits.PMOD = 3; //0=complementary mode,2=push pull mode,3 = independent mode
     IOCON1bits.OVRENH = 0; //PWMmodule provides data for this pin
     IOCON1bits.OVRENL = 0; //PWM module provide data for this pin
     //IOCON1bits.OVRDAT = 0;
     //IOCON1bits.OSYNC = 1;
     
     
     
     PWMCON2bits.ITB = 1; //  =0 ->USe PTPER register for pwm timing.1 -> use
     //phase and sphase
     PWMCON2bits.MDCS = 0; //use PDCx registers for duty cycle
     PWMCON2bits.DTC = 0; // dead-time control disabled
     PWMCON2bits.CAM = 1;//center aligned mode disabled
     PWMCON2bits.XPRES = 0;// external pins have no effect on pwm time base
     PWMCON2bits.IUE = 0; // update PDCx with PWM time base
     
     //DTR2 = 50;
    // ALTDTR2 = 200;//was 100
     
     IOCON2bits.PENH = 1; //PWMmodule controls this pin
     IOCON2bits.PENL = 1; //PWM module controls this pin
     IOCON2bits.POLH = 0; //active high pin
     IOCON2bits.POLL = 0; //active high pin
     IOCON2bits.PMOD = 3; //0=complementary mode,2=push pull
     IOCON2bits.OVRENH = 0; //PWMmodule provides data for this pin
     IOCON2bits.OVRENL = 0; //PWM module provide data for this pin
     //IOCON2bits.OSYNC = 1;
     
     // to generate a 60Hz interrupt I may have to come up with a function to 
     // increment the trigger counter because the scalers are maxed out and it is only at
     // 786Hz
     //TRIG1 = 0; --> Only used when pwm generator is local time base?
     
     //TRGCON1bits.TRGDIV = 3;// trigger output every 4th event/period(was a 3))
     //TRGCON1bits.TRGSTRT = 0;//first trigger event occurs after four trigger match events(was 0))
     //PWMCON1bits.TRGIEN = 1;//trigger event generates an interrupt request

     
    IOCON2bits.OVRDAT0 = 1; // bottom FET (Q4) held high while PDC1 PWMs
    IOCON2bits.OVRDAT1 = 0; // Top FET (Q3) Held low while it doesn't pulse        
    IOCON1bits.OVRDAT1 = 0; // top FET goes low when not pulsing
    IOCON1bits.OVRDAT0 = 1;  // bottom fet goes high when not pulsing
     
     
     PTCONbits.PTEN = 1; // 1 = PWM timer base ON. 0 = PWM timer base OFF
     //IEC5bits.PWM1IE = 1; //PWM interrupt ON
 }


void InitTimer1(void)
{
    T1CONbits.TSIDL = 0; //continue timer even when device is in idle mode.
    T1CONbits.TGATE = 0;// --> when TCS = 0 this bit is ignored
    T1CONbits.TCKPS1 = 2; // 0=1:1, 1=1:8, 2=1:64, 3=1:256
    //T1CONbits.TSYNC = 0 --> Ignored when TCS=0
    T1CONbits.TCS = 0; //Internal clock. (FOSC/2)
    PR1 = (2625);//was 5208/2
    
    IPC0bits.IC1IP = 1; //set interrupt priority
    IFS0bits.T1IF = 0; //clear the timer1 interrupt flag
    IEC0bits.T1IE = 1; //Enable timer1 interrupt
    
    T1CONbits.TON = 1; //Timer ON
}






void InitADC(void)
{
    ADCONbits.FORM = 0; // Output in Integer Format
    ADCONbits.EIE = 0; // Enable Early Interrupt
    ADCONbits.ORDER = 0; // Normal Order of Conversion
    ADCONbits.SEQSAMP = 0; // Simultaneous Sampling
    ADCONbits.ASYNCSAMP = 1; // Asynchronous Sampling
    ADCONbits.SLOWCLK = 1; // High Frequency Clock Input
    ADCONbits.ADCS = 5; // Clock Divider Selection
    
    ADCPC0bits.TRGSRC0=0b01100; 
    
     /*Trigger source:
     * 0b00001 = Individual software trig source
     * 0b00010 = global software trigger source
     * 0b11111 = Timer2 match trigger Source 
     * 0b01100 = Timer1 source
     */
    
    ADPCFGbits.PCFG0 = 0; // AN0 is configured as analog input
    ADPCFGbits.PCFG1 = 0; // AN1 configured as analog input
    
    IPC27bits.ADCP0IP = 1; // Set ADC Pair 0 Interrupt Priority (Level 1)
    IFS6bits.ADCP0IF = 0; // Clear ADC Pair 0 Interrupt Flag
    IEC6bits.ADCP0IE = 1; // Enable ADC Pair 0 Interrupt
    ADCONbits.ADON = 1; // Enable ADC Module
}

void InitUART(void)

/*
 * LSB
 * 8 bits
 * No Parity
 * Idle Low
 * 
 * Tested with Cool Term. When AN0 is supplied with 1.60Vdc we get a reading of 0x80 which 
 * is right in the middle of the 10 bit augmented to 8 bit ADC
 */
{       
        U1MODEbits.UARTEN = 0; // Disable UART 
        U1MODEbits.STSEL = 0; // 1-stop bit
        U1MODEbits.PDSEL = 0; // No Parity, 8-data bits
        U1MODEbits.ABAUD = 0; // Autobaud Disabled
        U1MODEbits.BRGH = 0; // Low Speed mode
    
        U1BRG = Baud_Rate; // BAUD Rate Setting for 9600
        U1STAbits.UTXINV = 1; // bus idle state low
        U1STAbits.URXISEL = 0; // Tx interrput mode. see pg 7 of DS70000582E (UART module))
        U1STAbits.UTXISEL0 = 0; // Interrupt after one Tx character is transmitted
        U1STAbits.UTXISEL1 = 0;   
        IEC0bits.U1TXIE = 1; // Enable UART TX interrupt        
        U1MODEbits.UARTEN = 1; // Enable UART       
        U1STAbits.UTXEN = 1; // Enable UART Tx
        
        
        Delay(50000);
        U1TXREG = 'a'; // Transmit one character
}

void RemapPins(void)
{
    OSCCONL = 0x46; // see page 151 of dspic33fj06gs302 manual
    OSCCONL = 0x57; // see page 151 of dspic33fj06gs302 manual
    OSCCONbits.IOLOCK = 0; // Unlock remappable I/O

    //__builtin_write_OSCCONL(OSCCON & 0xDF);
    
   // RPINR18bits.U1RXR = 1;//RP1, Pin 9 (RB1) UART Rx see page 159 dspic33fj06gs302 manual
    RPOR0bits.RP0R = 0b000011;//RP2, Pin 10(RB2) UART Tx see page 150 of dspic33fj06gs302 manual
    
   // __builtin_write_OSCCONL(OSCCON | 0x40); 
     
    OSCCONL = 0x57; // see page 151 of dspic33fj06gs302 manual
    OSCCONL = 0x46; // see page 151 of dspic33fj06gs302 manual
    OSCCONbits.IOLOCK = 1; // Lock remappable I/O

}

void __attribute__((interrupt, no_auto_psv))_ADCP0Interrupt (void)
{   
    IFS6bits.ADCP0IF = 0;
    LATBbits.LATB5 = 1; // blink an led
    
 // if(i >=10 )
 // {
 //     i=0;
 // }
 // else
 // {
     Sample1 = ADCBUF0;   
 // }
    //ADCBUF0 = 0;
  //  i++;  
        
}

void Delay(time)
{
    j=0;
     {
        
     //j=0;
     
     while(j<time) //while(j<630) //roughly 0.254ms delay. 315=~60hz
     {
         j++;
     }
 }
}
 

void __attribute__((__interrupt__)) _U1TXInterrupt(void)
{
    /*Below Sample1 is shifted 2 places to the right. This is because the ADC value is 10 bits long 
     * and the Tx register is 8 bits long. By doing this we are turning our 10 bit ADC into 
     * an 8 bit adc by chopping off the first two bits (LBSs). This is not the best way but 
     * for it is easy and works for now. The below was tested with a pot and cool Term 
     * software.
     * **********************REMEBER THE ADC HAS A Vref OF 3.3Vdc*********************************** 
     */
    
    IFS0bits.U1TXIF = 0; // Clear TX Interrupt flag

    Sample1 =  (Sample1>>2);  // shift 2 places right
    
    U1TXREG = Sample1;

    Sample1 = 0;
}
void __attribute__((interrupt, no_auto_psv))_PWM1Interrupt( void )
{
    LATBbits.LATB9 = ~LATBbits.LATB9;
    LATBbits.LATB10 = ~LATBbits.LATB10;
    IFS5bits.PWM1IF = 0;// clearing PWM1 interrupt flag
}
 
/*Timer1 Interrupt Service Routine*/
void __attribute__((interrupt, auto_psv))_T1Interrupt( void )
{   
    
    PwmDutyUpdate();
        
    IFS0bits.T1IF = 0; // clear interrupt flag
 
}

//void __attribute__((interrupt, auto_psv))_T2Interrupt( void )
//{
//    IFS0bits.T1IF = 0;
//}
